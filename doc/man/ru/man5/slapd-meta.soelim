.\" $ReOpenLDAP$
.\" Copyright 1992-2018 ReOpenLDAP AUTHORS: please see AUTHORS file.
.\" All rights reserved.
.\"
.\" This file is part of ReOpenLDAP.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted only as authorized by the OpenLDAP
.\" Public License.
.\"
.\" A copy of this license is available in the file LICENSE in the
.\" top-level directory of the distribution or, alternatively, at
.\" <http://www.OpenLDAP.org/license.html>.

.TH SLAPD-META 5 "@RELEASE_DATE@" "ReOpenLDAP @VERSION@"

.SH НАЗВАНИЕ
slapd\-meta \- механизм манипуляции данными метакаталога для slapd

.SH ОБЗОР
@SYSCONFDIR@/slapd.conf

.SH ОПИСАНИЕ
Механизм манипуляции данными для
.BR slapd (8)
.B meta
выполняет базовое проксирование LDAP по отношению к набору удалённых серверов LDAP, называемых
"целями". Информация, содержащаяся в этих серверах может быть представлена как принадлежащая одному
информационному дереву каталога (DIT).
.LP
Рекомендуется обладать базовыми знаниями по функциональности механизма манипуляции данными
.BR slapd\-ldap (5).
Данный механизм манипуляции данными разрабатывался как усовершенствование механизма манипуляции данными
ldap. Оба этих механизма имеют много общих функций (в действительности, они разделяют также части
исходного кода). Если механизм
.B ldap
предназначен для выполнения прокси-операций в отношении одного сервера, то механизм
.B meta
в основном предназначен для проксирования нескольких серверов с возможностью подмены пространства имён.
Эти функции, безусловно полезные во многих ситуациях, могут привести к чрезмерному расходу ресурсов
для некоторых приложений, поэтому использование данного механизма должно быть тщательно продумано.
Некоторые типичные сценарии использования будут обсуждаться в разделе примеров.

Экземпляр
.BR slapd (8),
реализующий прокси-сервер, должен иметь сведения схемы данных для атрибутов и объектных классов,
используемых в фильтрах, запрашиваемых DN и другой относящейся к запросам информации. Он должен также
иметь сведения схемы данных для данных, возвращаемых удалённым сервером. Ответственность за поддержание
схемы данных прокси-сервера в актуальном (относительно удалённых серверов) состоянии лежит на
администраторе этого прокси-сервера.

.LP
Примечание: При подключении к тому же самому экземпляру \fBslapd\fP(8), каждое соединение требует
создания нового потока; как следствие, \fBslapd\fP(8) должен быть скомпилирован с поддержкой потоков
и может понадобиться произвести некоторые настройки в параметре \fBthreads\fP. В этих случаях, если
не требуется функционал обращения к нескольким целям, может быть предпочтительнее воспользоваться
механизмом манипуляции данными \fBslapd\-relay\fP(5), который выполняет транслируемые операции внутри
и потому повторно использует то же самое соединение.

.SH ПРИМЕРЫ
Примеры приводятся во многих местах этого документа, а также в директории slapd/back\-meta/data/
дерева исходного кода ReOpenLDAP.
.SH КОНФИГУРАЦИЯ
Приведённые ниже директивы
.B slapd.conf
применяются к базам данных механизма манипуляции данными META. То есть они должны следовать за строкой
"database meta" и находиться до последующих строк "backend" или "database".
Другие относящиеся к базам данных директивы описаны в man-странице
.BR slapd.conf (5).
.LP
Примечание: В ранних версиях back-ldap и back-meta было рекомендовано всегда устанавливать
.LP
.RS
.nf
lastmod  off
.fi
.RE
.LP
для баз данных
.B ldap
и
.BR meta .
Это было необходимо, потому что проксирование не должно выполняться для операционных атрибутов,
относящихся к созданию и модификации записи, поскольку они могут быть ошибочно записаны на целевой
сервер (серверы) и привести к ошибке. Текущая реализация автоматически устанавливает lastmod в
\fBoff\fP, поэтому использование этой директивы избыточно и указывать её не следует.

.SH ДИРЕКТИВЫ КОНФИГУРАЦИИ, СПЕЦИАЛЬНЫЕ ДЛЯ МЕХАНИЗМА META
Конфигурация цели начинается с директивы "uri". Перед ней (для ясности) следует указывать все директивы,
не являющиеся специфичными для целей, в том числе те, которые являются общими для всех механизмов
манипуляции данными. Это директивы:

.TP
.B conn\-ttl <time>
Задаёт время жизни (ttl), после которого закэшированное соединение будет прервано и создано заново
независимо от того, простаивает это соединение или нет.

.TP
.B default\-target none
Указывает механизму манипуляции данными отклонять все операции, которые должны быть обслужены одним
сервером-целью, в случае, если цели не выбраны, либо выбрано несколько целей. К таким операциям
относятся add, delete, modify, modrdn. Операции compare и bind не входят в этот список, поскольку
они не изменяют записей, и, в случае нахождения нескольких совпадений, будет предпринята попытка
выполнить операцию в любой цели-кандидате, но успешно может быть завершено не более одной такой
операции. Также эта директива может быть использована при обработке целей, чтобы пометить конкретную
цель как используемую по умолчанию.

.TP
.B dncache\-ttl {DISABLED|forever|<ttl>}
Задаёт время жизни кэша DN. В этот кэш помещается цель, в которой содержится заданный DN, для ускорения
выбора цели в случае возвращения нескольких целей в результате некэшированного поискового запроса.
Вариант forever означает, что кэш не устаревает никогда; вариант disabled означает, что кэш DN не ведётся;
в третьем варианте требуется указать правильный (больший нуля) ttl в формате, данном в описании директивы
.BR idle\-timeout.

.TP
.B onerr {CONTINUE|report|stop}
Позволяет выбрать поведение в случае возвращения одной из целей ошибки во время поиска. Вариант по
умолчанию, \fBcontinue\fP, состоит в продолжении выполнения операции и попытке вернуть как можно больше
данных. Если в качестве значения директивы указано \fBstop\fP, поиск прекращается сразу же, как только
одна из целей вернула ошибку, и эта ошибка немедленно передаётся клиенту. Если в качестве значения
директивы указано \fBreport\fP, поиск продолжается до конца, но, в случае, если хотя бы одна цель вернула
ошибочный код, возвращается первый неуспешный код ошибки.

.TP
.B norefs <NO|yes>
Если этот параметр установлен в
.BR yes ,
в ответ на поисковые запросы не будут возвращаться поисковые ссылки-продолжения. По умолчанию
ответы с такими ссылками возвращаются (если только версия протокола запроса не была LDAPv2).
При указании перед спецификациями целей, действие директивы распространяется на все цели,
если оно не переопределяется этой же директивой в настройках конкретной цели.

.TP
.B noundeffilter <NO|yes>
Если этот параметр установлен в
.BR yes ,
то в случаях, когда поисковый фильтр неопределён или содержит неопределённые элементы, вместо
выполнения поиска будет сразу возвращён успешный результат. По умолчанию поисковый запрос,
после замены неопределённых элементов фильтра на
.BR (!(objectClass=*)) ,
передаётся удалённому серверу; поиковый фильтр с такими элементами соответствует пустому
результирующему набору.
При указании перед спецификациями целей, действие директивы распространяется на все цели,
если оно не переопределяется этой же директивой в настройках конкретной цели.

.TP
.B protocol\-version {0,2,3}
Эта директива указывает, какая версия протокола должна использоваться при работе с удалённым
сервером. Если задано значение 0 (по умолчанию), прокси использует ту же версию протокола, что и
клиент, иначе используется указанная явно версия протокола. Прокси возвращает ошибку \fIunwillingToPerform\fP
при попытке выполнения операции, несовместимой с запрашиваемой версией протокола. При указании перед
спецификациями целей, действие директивы распространяется на все цели, если оно не переопределяется
этой же директивой в настройках конкретной цели.

.TP
.B pseudoroot\-bind\-defer {YES|no}
Если эта директива установлена в
.BR yes ,
то аутентификация на удалённом сервере от имени идентификационной сущности псевдо-администратора (pseudo-root,
идентификационная сущность, определяемая в директиве
.BR idassert\-bind )
будет отложена до тех пор, пока фактически не понадобится для выполнения последующих операций.
В противном случае все подсоединения от имени rootdn будут сразу передаваться на цели.

.TP
.B quarantine <interval>,<num>[;<interval>,<num>[...]]
Включает режим карантина для тех URI, при обращении к которым был возвращён код
.IR LDAP_UNAVAILABLE ,
так что попытки повторного соединения будут выполняться только через заданные временные интервалы,
а не каждый раз, когда клиент запрашивает выполнение операции. Шаблон для определения алгоритма
выполнения повторных попыток следующий: выполнять повторную попытку после того, как пройдёт как минимум
.I interval
секунд после прошлой попытки, ровно
.I num
раз; затем использовать следующий шаблон. Если в последнем шаблоне в качестве
.I num
указано "\fB+\fP", повторные попытки будут выполняться неограниченное количество раз; в противном случае,
после отработки последнего шаблона попыток подключения больше выполняться не будет. Эта директива должна
указываться перед спецификациями целей; один и тот же шаблон распространяется на все цели.

.TP
.B rebind\-as\-user {NO|yes}
Если этот параметр задан, учётные данные подсоединения клиента запоминаются для последующих подключений
при попытке повторной установки разорванного соединения, либо при разрешении отсылок, если параметр
.B chase\-referrals
установлен в
.IR yes .

.TP
.B session\-tracking\-request {NO|yes}
Этот параметр указывает, следует ли добавлять во все запросы элемент управления отслеживания сессии
(session tracking). Ассоциированные с каждым запросом IP-адрес и имя хоста клиента, а также его
идентификационная сущность (если они известны), передаются удалённому серверу в информационных целях.
Этот параметр нельзя использовать, если параметр \fIprotocol\-version\fP установлен в 2. При указании
перед спецификациями целей, действие директивы распространяется на все цели, если оно не переопределяется
этой же директивой в настройках конкретной цели.

.TP
.B single\-conn {NO|yes}
Указывает, следует ли сбрасывать текущее закэшированное соединение при выполнении клиентом
повторного подсоединения.

.TP
.B use\-temporary\-conn {NO|yes}
Если этот параметр установлен в
.BR yes ,
то, когда при попытке обращения к удалённому серверу общее соединение занято другими процессами,
создаётся временное соединение; в противном случае, процесс ждёт, когда общее соединение станет доступным.

.SH СПЕЦИФИКАЦИЯ ЦЕЛИ
Спецификация цели начинается с директивы "uri":

.TP
.B uri <protocol>://[<host>]/<naming context> [...]
В качестве части <protocol> может указываться всё, что принимает вызов
.BR ldap_initialize (3)
({ldap|ldaps|ldapi} и разновидности); часть <host> может быть опущена, значение по умолчанию берётся из настроек
.BR ldap.conf (5).
Часть <naming context> является \fIобязательной\fP для первого URI, но \fIдолжна быть опущена\fP в
последующих URI, если они присутствуют. Часть <naming context> URI должна "входить" в контекст
именования базы данных механизма meta, например:
.LP
.RS
.nf
suffix "\fBdc=foo,dc=com\fP"
uri    "ldap://x.foo.com/dc=x,\fBdc=foo,dc=com\fP"
.fi

.RE
.RS
Не требуется, чтобы часть <naming context> была уникальна среди всех целей; она может также совпадать
с одним из значений директивы "suffix". В одной директиве uri могут быть определены несколько URI.
Дополнительные URI должны представлять собой отдельные аргументы и не должны иметь части <naming context>.
При указании нескольких URI библиотека будет взаимодействовать с первым доступным сервером из списка.
Например, если \fIl1.foo.com\fP и \fIl2.foo.com\fP - это реплики одного и того же сервера, то при настройках
.LP
.nf
suffix "\fBdc=foo,dc=com\fP"
uri    "ldap://l1.foo.com/\fBdc=foo,dc=com\fP" "ldap://l2.foo.com/"
.fi

.RE
.RS
обращение к серверу \fIl2.foo.com\fP будет происходить, если сервер \fIl1.foo.com\fP не отвечает.
В таких случаях список URI внутренне переупорядочивается так, что недоступные URI перемещаются в конец,
и при последующих соединениях предпочтение будет отдаваться последнему успешно ответившему URI.
.RE

.TP
.B acl\-authcDN "<административное DN, используемое для проверки контроля доступа>"
Задаёт DN, используемое при подсоединении к целевому серверу с целью проверки ACL, как в механизме LDAP.
Предполагается, что идентификационная сущность, определяемая записью, указанной в этой директиве, будет
иметь на целевом сервере доступ на чтение к атрибутам, используемым на прокси-сервере для проверки ACL.
Задавая подобные настройки, вы ничем не рискуете; они используются только для проверки прав доступа.
.B Идентификационная сущность acl\-authcDN ни при каких обстоятельствах не используется прокси неявно
.B при выполнении клиентом анонимного подключения.

.TP
.B acl\-passwd <password>
Задаёт пароль для записи, указанной в директиве
.BR acl\-authcDN .

.TP
.B bind\-timeout <microseconds>
Определяет таймаут (в микросекундах), используемый при ожидании ответа на запрос асинхронного подсоединения
bind. Первоначальный вызов ldap_result(3) выполняется с компромиссным таймаутом в 100000 миллисекунд;
если этот таймаут будет превышен, последующие вызовы используют значение, указанное в директиве
.BR bind\-timeout .
Если директива
.B bind\-timeout
не определялась, последующие вызовы также используют значение по умолчанию. При указании перед спецификациями
целей, действие директивы распространяется на все цели, если оно не переопределяется этой же директивой
в настройках конкретной цели.

.TP
.B chase\-referrals {YES|no}
Включает/отключает автоматический переход по отсылкам, осуществление которого делегируется библиотеке
libldap. При этом, если используется директива \fBrebind\-as\-user\fP, выполняется повторное
подсоединение. По умолчанию переход по отсылкам осуществляется. При указании перед спецификациями
целей, действие директивы распространяется на все цели, если оно не переопределяется этой же директивой
в настройках конкретной цели.

.TP
.B client\-pr {accept-unsolicited|DISABLE|<size>}
Эта директива позволяет использовать элемент управления Paged Results (RFC 2696) при выполнении операций
поиска в конкретной цели, вне зависимости от запроса клиента. При указании числового значения, в элементе
управления Paged Results в качестве размера страницы всегда используется \fIsize\fP. При указании
\fIaccept-unsolicited\fP ответы с установленным элементом управления Paged Results будут приниматься и
обрабатываться даже когда этот элемент управления не запрашивался (в целях совместимости с плохо
реализованными удалёнными DSA). Клиент не ставится в известность о том, что между
.BR slapd\-meta (5)
и удалёнными серверами выполняются запросы с обработкой постраничных результатов. По умолчанию (disable),
элемент управления Paged Results не используется, и ответы, в которых он установлен, не принимаются.
При указании перед спецификациями целей, действие директивы распространяется на все цели, если оно
не переопределяется этой же директивой в настройках конкретной цели.

.TP
.B default\-target [<target>]
Директива default\-target также может использоваться при настройке цели. Если аргументы не указаны,
то текущая цель помечается как цель по умолчанию. При указании опционального числового аргумента,
цель <target> помечается как цель по умолчанию. Нумерация целей начинается с 1. Цель, указанная в
аргументе <target>, должна быть определена.

.TP
.B filter <pattern>
Данная директива позволяет задать шаблон регулярного выражения
.BR regex (5)
для указания того, какие конкретно поисковые фильтры будут обслуживаться сервером-целью.

Если фильтр в поисковом запросе соответствует шаблону \fIpattern\fP, данная цель принимается во внимание
при выполнении этого запроса; в противном случае, данная цель игнорируется. Для каждой цели может быть
указано несколько директив
.BR filter .

.TP
.B idassert\-authzFrom <authz\-regexp>
Эта директива, если указана, определяет, каким
.I локальным
идентификационным сущностям разрешено использовать возможность утверждения идентификационной
сущности. Строка
.B <authz\-regexp>
подчиняется правилам, определённым для атрибута
.IR authzFrom .
Подробное описание синтаксиса этого поля можно найти в разделе man-страницы
.BR slapd.conf (5),
посвящённом директиве
.BR authz\-policy .

.HP
.hy 0
.B idassert\-bind
.B bindmethod=none|simple|sasl [binddn=<simple DN>] [credentials=<simple password>]
.B [saslmech=<SASL mech>] [secprops=<properties>] [realm=<realm>]
.B [authcId=<authentication ID>] [authzId=<authorization ID>]
.B [authz={native|proxyauthz}] [mode=<mode>] [flags=<flags>]
.B [starttls=no|yes|critical]
.B [tls_cert=<file>]
.B [tls_key=<file>]
.B [tls_cacert=<file>]
.B [tls_cacertdir=<path>]
.B [tls_reqcert=never|allow|try|demand]
.B [tls_cipher_suite=<ciphers>]
.B [tls_protocol_min=<major>[.<minor>]]
.B [tls_crlcheck=none|peer|all]
.RS
Позволяет определять параметры метода аутентификации, используемого внутренне прокси-сервером для
авторизации соединений, при выполнении которых удалённая база данных требует (может произвести)
аутентификацию. Предполагается, что идентификационная сущность, указанная в этой директиве (в
соответствии со свойствами выбранного метода аутентификации), будет иметь на целевом сервере доступ
auth (на выполнение аутентификации) к атрибутам, используемым на прокси-сервере для аутентификации
и авторизации. Кроме того, предполагается, что этой идентификационной сущности разрешено производить
авторизацию пользователей. Для этого требуется иметь привилегии
.B proxyAuthz
к широкому диапазону DN, например,
.BR authzTo=dn.subtree:"" ,
а также чтобы на удалённом сервере директива
.B authz\-policy
была установлена в
.B to
или
.BR both .
Подробное описание этих настроек, а также замечания по их использованию и недостаткам можно найти в man-странице
.BR slapd.conf (5).
Поддерживаемые методы bindmethod:

\fBnone|simple|sasl\fP

По умолчанию используется значение
.BR none ,
то есть никакого \fIутверждения идентификационной сущности\fP не выполняется.

Параметр authz используется для указания того, что при подсоединении SASL должна применяться простая
.B (native)
авторизация SASL, если таковая доступна; поскольку соединения кэшируются, эту возможность следует использовать,
только когда авторизация выполняется с фиксированной идентификационной сущностью (например, посредством параметров
.B authzDN
или
.BR authzID ).
В противном случае используется значение по умолчанию -
.BR proxyauthz ,
то есть ко всем операциям добавляется элемент управления proxyAuthz (Proxied Authorization, RFC 4370).

Поддерживаемые режимы (аргумент mode):

\fB<mode> := {legacy|anonymous|none|self}\fP

Если значение
.B <mode>
не указано, но задан параметр
.BR authzId ,
прокси всегда будет выполнять авторизацию от имени этой идентификационной сущности. Значение
.B <authorization ID>
может быть задано в форматах

\fBu:<user>\fP

\fB[dn:]<DN>\fP

Предполагается, что значение идентификационной сущности в первом формате будет расширено удалённым
сервером в соответствии с правилами authz; подробнее смотрите в man-странице
.BR slapd.conf (5).
Если применяется второй формат, независимо от того, присутствует префикс
.B dn:
или нет, указываемая строка должна удовлетворять требованиям валидации и нормализации DN.

Режим по умолчанию -
.BR legacy ,
при котором подразумевается, что прокси-сервер будет либо выполнять простое подсоединение от имени
.IR authcDN ,
либо SASL-подсоединение от имени
.IR authcID ,
а затем производить утверждение идентификационной сущности клиента, если тот не пытается подсоединиться
анонимно. Прямые подсоединения всегда проксируются. При других режимах подразумевается, что
прокси-сервер всегда будет либо выполнять простое подсоединение от имени
.IR authcDN ,
либо SASL-подсоединение от имени
.IR authcID ,
если это не ограничивается правилами
.B idassert\-authzFrom
(смотрите выше), в таком случае операция будет завершена неудачей; после подсоединения прокси будет
выполнять утверждение некоторой другой идентификационной сущности в зависимости от режима
.BR <mode> .
В режиме
.BR anonymous
будет выполняться утверждение
.B пустой
идентификационной сущности. В режиме
.BR self
будет выполняться утверждение
.I идентификационной сущности клиента.
В режиме
.BR none
элемент управления proxyAuthz использоваться не будет, таким образом будет выполняться утверждение
идентификационной сущности
.I authcDN
или
.IR authcID .
Для всех режимов, требующих использования элемента управления
.IR proxyAuthz ,
идентификационная сущность прокси-сервера должна иметь на удалённом сервере соответствующие права
.IR authzTo ,
либо у утверждаемых идентификационных сущностей должны быть соответствующие права
.IR authzFrom .
Следует, однако, отметить, что функция утверждения идентификационных сущностей полезна, главным образом,
когда утверждаемые идентификационные сущности не существуют на удалённом сервере.

В качестве флагов (аргумент flags) могут быть заданы

\fBoverride,[non\-]prescriptive,proxy\-authz\-[non\-]critical\fP

При использовании флага
.B override
утверждение идентификационной сущности выполняется, даже когда подключение к базе данных уже авторизовано
для идентификационной сущности клиента. То есть после выполнения подсоединения с предоставленной
идентификационной сущностью (и, как следствие, проведения её аутентификации), прокси выполняет
утверждение идентификационной сущности, используя заданную в конфигурации идентификационную сущность и
метод аутентификации.

При использовании флага
.B prescriptive
(по умолчанию), операции будут завершаться неудачей с кодом \fIinappropriateAuthentication\fP для
тех идентификационных сущностей, утверждение которых не разрешено шаблонами из директивы
.BR idassert\-authzFrom .
При использовании флага
.BR non\-prescriptive ,
для тех идентификационных сущностей, утверждение которых не разрешено шаблонами из директивы
.BR idassert\-authzFrom ,
операции выполняются анонимно.

При использовании флага
.B proxy\-authz\-non\-critical
(по умолчанию), элемент управления proxyAuthz не помечается как критичный (в нарушение требований
RFC 4370). Рекомендуется использование флага
.BR proxy\-authz\-critical .

Значения по умолчанию настроек TLS соответствуют значениям основных настроек TLS slapd, за исключением параметра
.BR tls_reqcert ,
значением по умолчанию которого является "demand".

Ассоциированная с этой директивой идентификационная сущность также используется для привилегированных
операций в случаях, когда директива \fBidassert\-bind\fP задана, а \fBacl\-bind\fP - нет. Подробнее
смотрите в описании директивы \fBacl\-bind\fP.
.RE

.TP
.B idle\-timeout <time>
При задании этой директивы закэшированные соединения будут прерываться и создаваться заново,
после того, как их простой превысит указанное время. Значение времени указывается как

[<d>d][<h>h][<m>m][<s>[s]]

где <d>, <h>, <m> и <s> интерпретируются, соответственно, как дни, часы, минуты и секунды. При указании
перед спецификациями целей, действие директивы распространяется на все цели, если оно не переопределяется
этой же директивой в настройках конкретной цели.

.TP
.B keepalive  <idle>:<probes>:<interval>
В параметре
.B keepalive
задаются значения \fIidle\fP, \fIprobes\fP и \fIinterval\fP, используемые для того, чтобы выяснить,
находится ли сокет в рабочем состоянии.
.I idle
- это количество секунд, в течении которого соединение должно оставаться в режиме ожидания,
прежде чем TCP начнёт посылать пробы keepalive;
.I probes
- это максимальное количество проб keepalive, которые будет посылать TCP перед тем,
как разорвать соединение;
.I interval
- это интервал в секундах между отдельными пробами keepalive. Не все системы поддерживают возможность
настройки этих значений пользователем; в этом случае параметр
.B keepalive
игнорируется и используются общесистемные установки.

.TP
.B map "{attribute|objectclass} [<local name>|*] {<foreign name>|*}"
Отображает объектные классы и атрибуты как в механизме манипуляции данными LDAP. Смотрите
.BR slapd\-ldap (5).

.TP
.B network\-timeout <time>
Устанавливает значение таймаута, после которого, в случае отсутствия сетевой активности,
будет возвращаться
.BR poll (2)/ select (2),
а затем
.BR connect (2).
Значение указывается в секундах, и его можно задать таким же, как и для директивы
.BR idle\-timeout .
При указании перед спецификациями целей, действие директивы распространяется на все цели, если оно
не переопределяется этой же директивой в настройках конкретной цели.

.TP
.B nretries {forever|never|<nretries>}
Определяет, сколько раз следует выполнять повторные попытки подсоединения при временной недоступности
цели. При указании перед спецификациями целей, действие директивы распространяется на все цели (по умолчанию
.BR 3
раза); глобальное значение может быть переопределено указанием этой же директивы в настройках конкретной цели.

.TP
.B rewrite* ...
Параметры перезаписи описываются в разделе "ПЕРЕЗАПИСЬ".

.TP
.B subtree\-{exclude|include} "<rule>"
Эта директива позволяет указать, какие конкретно поддеревья будут обслуживаться сервером-целью.
Синтаксис поддерживаемых правил:

\fB<rule>: [dn[.<style>]:]<pattern>\fP

\fB<style>: subtree|children|regex\fP

Если в качестве \fB<style>\fP указано \fBsubtree\fP или \fBchildren\fP, шаблон \fB<pattern>\fP
представляет собой DN, который должен быть в пределах контекста именования, обслуживаемого целью.
Если в качестве \fB<style>\fP указано \fBregex\fP, \fB<pattern>\fP представляет собой шаблон
регулярного выражения
.BR regex (5).
Если префикс \fBdn.<style>:\fP опущен, для соблюдения обратной совместимости неявно подразумевается
\fBdn.subtree:\fP.

В форме
.BR subtree\-exclude ,
если \fIзапрашиваемое DN\fP соответствует хотя бы одному правилу, данная цель не принимается во внимание
при выполнении этого запроса; в противном случае, данная цель рассматривается, основываясь на значении
\fIзапрашиваемого DN\fP. Когда выполняемый запрос является поисковым, также принимается во внимание
диапазон поиска \fIscope\fP.

В форме
.BR subtree\-include ,
если \fIзапрашиваемое DN\fP соответствует хотя бы одному правилу, данная цель принимается во внимание
при выполнении этого запроса; в противном случае, данная цель игнорируется.

.LP
.RS
.nf
    | совпадение |  форма    |
    | с шаблоном |  exclude  |
    +------------+-----------+----------------------+
    |     Да     |    Да     | не кандидат          |
    |     Нет    |    Да     | продолжение проверки |
    +------------+-----------+----------------------+
    |     Да     |    Нет    | кандидат             |
    |     Нет    |    Нет    | не кандидат          |
    +------------+-----------+----------------------+
.fi

.RE
.RS
Для каждой цели может быть указано несколько директив
.B subtree\-exclude
или
.BR subtree\-include ,
но по отношению друг к другу они являются взаимоисключающими.
.RE

.TP
.B suffixmassage "<virtual naming context>" "<real naming context>"
Все директивы, начинающиеся с "rewrite", относятся к механизму перезаписи slapd. Директива suffixmassage
была представлена в механизме LDAP. С её помощью выполнялось преобразование суффикса во время проксирования.
С введением инструментов перезаписи директива считается устаревшей. Однако, она была сохранена как в
целях сохранения обратной совместимости, так и для упрощения конфигурирования в случаях, когда требуется
выполнение простого преобразования суффикса. Эту директиву можно рассматривать как сокращённую запись
базовых инструкций перезаписи, выполняющих преобразование суффикса. Список правил перезаписи,
подразумеваемых в этой директиве, можно найти в разделе "ПЕРЕЗАПИСЬ".

.TP
.B t\-f\-support {NO|yes|discover}
включает применение абсолютных фильтров (смотрите \fIRFC 4526\fP), если их поддерживает
удалённый сервер. Если задано значение
.BR discover ,
поддержка абсолютных фильтров удалённым сервером будет определяться путём опроса root DSE этого сервера.
При указании перед спецификациями целей, действие директивы распространяется на все цели, если оно
не переопределяется этой же директивой в настройках конкретной цели.

.TP
.B timeout [<op>=]<val> [...]
Этот параметр позволяет задавать таймауты для каждого типа операций. Операциями могут быть

\fB<op> ::= bind, add, delete, modrdn, modify, compare, search\fP

Общая продолжительность операции \fBsearch\fP контролируется либо параметром \fBtimelimit\fP поискового
запроса, либо ограничениями по времени, заданными на стороне сервера (смотрите директивы \fBtimelimit\fP
и \fBlimits\fP в man-странице
.BR slapd.conf (5)).
Данный параметр \fBtimeout\fP контролирует, насколько долго целевой сервер может не отвечать на запрос,
прежде чем операция будет прервана. Для операций, не указанных в списке (\fBunbind\fP и \fBabandon\fP),
назначать таймауты бессмысленно, поскольку они не подразумевают возвращения какого-либо ответа. Также
поддержка таймаутов не реализована для определённых на данный момент расширенных (\fBextended\fP)
операций. Если никакой операции \fBop\fP не указано, значение таймаута \fBval\fP применяется ко всем
поддерживаемым операциям. При указании перед спецификациями целей, действие директивы распространяется
на все цели, если оно не переопределяется этой же директивой в настройках конкретной цели.

Примечание: если превышено ограничение timelimit, выполняется отмена операции (в соответствии с
директивой \fBcancel\fP); протокол не предоставляет какого-либо способа отката операций, так что клиент
не будет оповещён о результате выполнения операции, была ли она в итоге удачной или нет. В случае
превышения таймаута во время выполнения операции bind, соединение разрывается в соответствии с RFC4511.

.TP
.B tls {[try\-]start|[try\-]propagate}
Указывает, что при инициализации соединения необходимо выполнить расширенную операцию StartTLS; работает,
только если в директиве URI не указана схема протокола \fBldaps://\fP. При значении \fBpropagate\fP
операция StartTLS будет вызываться, только если она вызывается в оригинальном соединении. Префикс
\fBtry\-\fP позволяет прокси продолжать выполнение операций, если операция StartTLS завершилась неудачей;
его использование крайне \fBне\fP рекомендуется. При указании перед спецификациями целей, действие директивы
распространяется на все цели, если оно не переопределяется этой же директивой в настройках конкретной цели.

.SH СЦЕНАРИИ РАЗВЁРТЫВАНИЯ
Мощный (и в некоторых отношениях опасный) механизм перезаписи был добавлен в оба механизма манипуляции
данными LDAP и META. Если первый из них может выиграть за счёт перезаписи относительно немного, во
втором перезапись может стать на удивление мощным инструментом.
.LP
Для начала рассмотрим пару сценариев.
.LP
1) Два сервера каталогов содержат два непересекающихся уровня одного контекста именования, скажем
"dc=a,dc=foo,dc=com" и "dc=b,dc=foo,dc=com". Тогда не имеющая внутренних противоречий база данных
META может быть настроена так:
.LP
.RS
.nf
database meta
suffix   "\fBdc=foo,dc=com\fP"
uri      "ldap://a.foo.com/dc=a,\fBdc=foo,dc=com\fP"
uri      "ldap://b.foo.com/dc=b,\fBdc=foo,dc=com\fP"
.fi
.RE
.LP
Из-за отсутствия неоднозначности легко определить, к какой цели будет направлена та или иная операция.
Единственная операция, которая приведёт к обращению к нескольким целям, это операция поиска search с
базой "dc=foo,dc=com" и диапазоном, как минимум, "one", в результате которой будет порождено два
поисковых запроса, по одному для каждой из целей.
.LP
2a) Два сервера каталогов не содержат какой-либо части определённого контекста именования, но их следует
представить как единое DIT [Предостережение: подразумевается уникальность (преобразованных) записей в
каталогах этих двух серверов; проверка целостности могла бы повлечь за собой чрезмерное расходование
ресурсов и не была реализована]. Предположим, у нас есть два каталога "dc=bar,dc=org" и "o=Foo,c=US",
и мы бы хотели, чтобы они выступали как ветки дерева "dc=foo,dc=com", скажем, "dc=a,dc=foo,dc=com" и
"dc=b,dc=foo,dc=com". Тогда нам нужно настроить базу данных META так:
.LP
.RS
.nf
database      meta
suffix        "dc=foo,dc=com"

uri           "ldap://a.bar.com/\fBdc=a,dc=foo,dc=com\fP"
suffixmassage "\fBdc=a,dc=foo,dc=com\fP" "dc=bar,dc=org"

uri           "ldap://b.foo.com/\fBdc=b,dc=foo,dc=com\fP"
suffixmassage "\fBdc=b,dc=foo,dc=com\fP" "o=Foo,c=US"
.fi
.RE
.LP
И вновь, направление операций к одной или другой цели можно определить без неоднозначности, хотя требуется
произвести некоторые преобразования. Обратите внимание, что виртуальные контексты именования каждой цели
являются ветками контекста именования базы данных; они перезаписываются туда и обратно при выполнении
операций в отношении целевых серверов. Что означает "туда и обратно" будет разъяснено позже.
.LP
Если выполняется поиск с базой "dc=foo,dc=com", то в случае указания диапазона "base" такой поиск
завершится неудачей с ошибкой "no such object"; фактически, общего корня двух целей (до преобразования)
не существует. Если указан диапазон "one", опрошены будут обе цели, при этом база поиска будет заменена
на базовую запись соответствующей цели, а диапазон понижен до "base". В общем случае, поиск с диапазоном
"one" будет выполнен и диапазон снижен, только если входная база поиска как минимум на один уровень
ниже контекста именования цели (до преобразования).
.LP
Наконец, если указан диапазон "sub", входная база будет заменена на непреобразованные контексты именования
каждой из целей, а диапазон оставлен без изменения.
.LP
2b) Теперь рассмотрим предыдущий сценарий, но при условии, что два сервера разделяют один и тот же
контекст именования:
.LP
.RS
.nf
database      meta
suffix        "\fBdc=foo,dc=com\fP"

uri           "ldap://a.bar.com/\fBdc=foo,dc=com\fP"
suffixmassage "\fBdc=foo,dc=com\fP" "dc=bar,dc=org"

uri           "ldap://b.foo.com/\fBdc=foo,dc=com\fP"
suffixmassage "\fBdc=foo,dc=com\fP" "o=Foo,c=US"
.fi
.RE
.LP
Всё вышесказанное остаётся в силе, за исключением того, что теперь нет способа однозначно определить
принадлежность DN. В этом случае все операции, требующие однозначного выбора цели, будут завершаться
неудачей, если только DN не был закэширован в результате предыдущих операций или не была назначена цель
по умолчанию. На практике, конфигурации могут представлять собой комбинацию всех описанных сценариев.
.SH ACL
Примечание по ACL: в настоящее время вы можете настраивать для механизма манипуляции данными META (и LDAP)
любые правила ACL. Однако, для понимания того, как будут функционировать ACL на прокси-сервере, может
потребоваться принять во внимание некоторые соображения. Рассмотрим две философии:
.LP
а) разрешения диктуются удалённым сервером; прокси просто передает клиенту то, что он получает от удаленного сервера.
.LP
б) удалённый сервер возвращает "всё подряд"; за защиту данных от несанкционированного доступа отвечает прокси.
.LP
Конечно, последний вариант выглядит менее разумно, но это не всегда так. Можно представить себе сценарий, когда
удалённый хост не ограничивает доступ к данным, которые считаются "открытыми" во внутренней сети, а
прокси-сервер, через который предоставляется доступ к этому хосту из внешней сети, может накладывать
дополнительные ограничения. Для этих целей прокси необходимо иметь возможность настройки всех поддерживаемых
сервером критериев поиска совпадений ACL. В настоящий момент механизмы прокси реализуют все возможные
критерии, поддерживаемые slapd, за исключением одного приведённого ниже специфического случая (пожалуйста,
оставьте запрос в ITS <http://www.openldap.org/its/>, если вы найдёте другие исключения): по правилу
.LP
.RS
.nf
access to dn="<dn>" attrs=<attr>
       by dnattr=<dnattr> read
       by * none
.fi
.RE
.LP
невозможно найти совпадение, если запрашиваемый атрибут <attr> не является <dnattr>, а атрибут определения
членства <dnattr> не был запрошен (например, в поисковом запросе).
.LP
В действительности, slapd разрешает данный ACL, используя часть полученной с удалённого сервера записи,
без какого-либо последующего привлечения механизма манипуляции данными. Таким образом, если атрибут <dnattr>
не был получен, совпадение оценить невозможно, и не потому, что нет значений атрибута, совпадающих с условием,
а потому, что необходимый атрибут не присутствует.
.LP
Примечание по ACL и отображению атрибутов: ACL применяются к отображённым атрибутам. Например, если атрибут,
известный на прокси как "foo", отображается на удалённом сервере в "bar", то локальные ACL применяются
к атрибуту "foo", и им ничего неизвестно об удалённом имени этого атрибута. Удалённый сервер будет проверять
разрешения для "bar", а локальный сервер, возможно, будет накладывать дополнительные ограничения на "foo".
.\"
.\" If this section is moved, also update the reference in
.\" libraries/librewrite/RATIONALE.
.\"
.SH ПЕРЕЗАПИСЬ
Строка преобразуется в соответствии с набором правил, называемых `контекстом перезаписи' (`rewrite
context'). Эти правила основаны на POSIX (''расширенных'') регулярных выражениях (regex) с совпадением подстрок;
специфические механизмы, подробно описанные далее, позволяют выполнять общую подстановку переменных
и разрешение подстрок с помощью карт.
Алгоритмы нахождения совпадения с шаблоном и подстановки можно изменять с помощью набора флагов.
.LP
Лежащая в основе идея заключалась в создании для сервера slapd легковесного модуля перезаписи
(изначально предназначавшегося для механизма манипуляции данными LDAP).
.SH Процесс работы
Во входной строке производится поиск совпадений с набором правил перезаписи.
Правила состоят из шаблона поиска совпадения с регулярным выражением, шаблона подстановки
и комбинации выполняемых действий, описываемых набором флагов.
В случае нахождения совпадения, преобразование строки выполняется в соответствии с шаблоном подстановки,
который позволяет использовать подстроки, совпавшие во входной строке. Если определены какие-либо
действия, они выполняются в самом конце. В шаблонах подстановки
разрешено выполнение разрешения подстрок с помощью так называемых карт. Карта - это некоторый объект,
отображающий шаблон подстановки в какое-то значение.
Флаги делятся на "Флаги управления поиском совпадений с шаблоном" и "Флаги действий"; первые управляют
поведением поиска совпадения с  шаблоном регулярного выражения, вторые - действиями, выполняемыми
после проведения подстановки.
.SH "Флаги управления поиском совпадений с шаблоном"
.TP
.B `C'
соблюдать регистр символов при сравнении строки с шаблоном (по умолчанию регистр символов игнорируется).
.TP
.B `R'
использовать ''основные'' регулярные выражения POSIX (по умолчанию используются ''расширенные'').
.TP
.B `M{n}'
разрешить не более чем
.B n
рекурсивных проходов для конкретного правила; этот флаг не отменяет максимального общего количества
проходов, таким образом он может только ужесточить ограничение для конкретного правила.
.SH "Флаги действий"
.TP
.B `:'
применить правило только один раз (по умолчанию применяется рекурсивно).
.TP
.B `@'
прекратить применять правила в случае совпадения; текущее правило всё ещё будет применяться рекурсивно;
для того чтобы применить текущее правило только один раз, а затем прекратить, используйте этот флаг
в комбинации с флагом `:'.
.TP
.B `#'
прекратить текущую операцию, если было найдено совпадение с правилом, и выдать ошибку
`unwilling to perform'.
.TP
.B `G{n}'
перейти на
.B n
правил назад и продолжить (опасайтесь зацикливания!).
Имейте ввиду, что `G{1}' подразумевается в каждом правиле.
.TP
.B `I'
игнорировать ошибки в правиле; это означает, что в случае возникновения ошибки, например, возникшей в ходе применения карты,
эта ошибка интерпретируется как отсутствие совпадения. Ошибка `unwilling to perform' не переопределяется.
.TP
.B `U{n}'
использовать
.B n
в качестве кода возврата, если было найдено совпадение с правилом; этот флаг не отменяет рекурсивного
выполнения правила, поэтому, если требуется, чтобы правило выполнялось только один раз, этот флаг должен
использоваться в комбинации с флагом  `:', например,
.B `:U{16}'
возвратит значение `16' после ровно одного выполнения правила, если было найдено совпадение с шаблоном.
Следовательно, поведение этого флага эквивалентно флагу `@', но при этом возвращается код
.BR n ;
другими словами, `@' эквивалентен `U{0}'.
По соглашению, включены свободно доступные коды возврата, большие 16-ти; остальные коды возврата зарезервированы.
.LP
Порядок указания флагов может иметь значение. Например, `IG{2}' означает игнорировать ошибки и переходить
на две строки вперёд как в случае нахождения совпадения, так и в случае ошибки, тогда как `G{2}I' означает
игнорировать ошибки, но осуществлять переход на две строки вперёд только в случае нахождения совпадения.
.LP
При необходимости будут добавлены дополнительные флаги (главным образом, флаги действий).
.SH "Шаблоны поиска совпадений"
Смотрите
.BR regex (7)
и/или
.BR re_format (7).
.SH "Синтаксис шаблонов подстановки"
Всё, что начинается с `%', требует подстановки;
.LP
единственное очевидное исключение - это `%%', которое оставляется как есть;
.LP
основная конструкция подстановки - `%d', где `d' это цифра; 0 означает строку целиком, а 1-9 -
это подсовпадения;
.LP
если за `%' следует `{', это означает выполнение расширенной подстановки. Шаблон такой подстановки:
.LP
.RS
`%' `{' [ <op> ] <name> `(' <substitution> `)' `}'
.RE
.LP
где <name> должно быть именем карты в правильном формате, то есть
.LP
.RS
.nf
<name> ::= [a-z][a-z0-9]* (регистр символов не имеет значения)
<op> ::= `>' `|' `&' `&&' `*' `**' `$'
.fi
.RE
.LP
а <substitution> должно быть шаблоном подстановки в правильном формате, без ограничений на уровень вложенности.
.LP
Операторы:
.TP
.B >
вызов подконтекста; <name> должно быть правильным, заранее определённым именем контекста перезаписи
.TP
.B |
вызов внешней команды; <name> должно указывать на правильное, заранее определённое имя команды
(ЕЩЁ НЕ РЕАЛИЗОВАНО)
.TP
.B &
присвоение значения переменной; <name> определяет переменную в структуре выполняемой операции, которая может быть разыменована позже; оператор
.B &
присваивает значение переменной в рамках текущего контекста перезаписи; оператор
.B &&
присваивает значение переменной в рамках всей сессии, то есть её значение может быть использовано позднее другими контекстами перезаписи
.TP
.B *
разыменование переменной; <name> должно указывать на переменную, которая определена и ей присвоено значение для выполняемой операции; оператор
.B *
разыменовывает переменную в рамках текущего контекста перезаписи; оператор
.B **
разыменовывает переменную в рамках всей сессии, то есть значение этой переменной доступно всем контекстам перезаписи
.TP
.B $
разыменование параметра; <name> должно указывать на существующий параметр; идея заключается в том,
чтобы сделать доступными механизму перезаписи некоторые задаваемые системой параметры времени исполнения,
такие как имя хоста клиента, DN подсоединения (если оно есть), параметры-константы, инициализируемые во
время конфигурации, и так далее; в настоящий момент механизмами
.B back\-ldap
и
.B back\-meta
не задаются никакие параметры, но в конфигурационном файле с помощью директивы
.B rewriteParam
можно определить параметры-константы.
.LP
Экранирование в строковых шаблонах подстановки осуществляется с помощью символа `%', который используется
вместо символа `\e', поскольку `\e' уже экранируется низкоуровневыми процедурами разбора slapd; как
следствие, при экранировании регулярных выражений требуется использовать два символа `\e', например,
выражение `\fB.*\e.foo\e.bar\fP' должно записываться как `\fB.*\e\e.foo\e\e.bar\fP'.
.\"
.\" The symbol can be altered at will by redefining the related macro in
.\" "rewrite-int.h".
.\"
.SH "Контексты перезаписи"
Контекст перезаписи - это набор правил, которые применяются последовательно. Основная идея состоит в том,
чтобы иметь приложение, инициализирующее механизм перезаписи (что-то вроде mod_rewrite в Apache), с
набором контекстов перезаписи; когда возникает потребность в преобразовании строки, вызывается соответствующий
контекст перезаписи с входной строкой, а на выходе (если не возникло ошибок) получается новая перезаписанная строка.
.LP
Все основные операции сервера ассоциированы с контекстами перезаписи; они подразделяются на две основные
группы: перезапись строк в сообщениях клиент \-> сервер и в сообщениях сервер \-> клиент.
.LP
клиент \-> сервер:
.LP
.RS
.nf
(default)            если определено правило и не указано
                     никакого конкретного контекста
bindDN               bind
searchBase           search
searchFilter         search
searchFilterAttrDN   search
compareDN            compare
compareAttrDN        compare AVA
addDN                add
addAttrDN            add AVA
modifyDN             modify
modifyAttrDN         modify AVA
modrDN               modrdn
newSuperiorDN        modrdn
deleteDN             delete
exopPasswdDN         DN расширенной операции password modify (если проксируется)
.fi
.RE
.LP
сервер \-> клиент:
.LP
.RS
.nf
searchResult         search (только если определён; нет значения по
                     умолчанию; выполняется над DN и атрибутами синтаксиса DN
                     результатов поиска)
searchAttrDN         search AVA
matchedDN            все операции (только если применение возможно)
.fi
.RE
.LP
.SH "Основные директивы конфигурации"
.TP
.B rewriteEngine { on | off }
Если эта директива задана в `on', настроенные процедуры перезаписи будут выполняться; если директива
задана в `off', перезапись выполняться не будет (простой способ остановить перезапись без
необходимости внесения слишком больших изменений в конфигурационный файл).
.TP
.B rewriteContext <context name> "[ alias <aliased context name> ]"
<context name> - это имя, идентифицирующее контекст, то есть имя, которое будет использоваться
приложением для того, чтобы обратиться к набору правил, содержащемуся в этом контексте. Кроме того,
это имя используется при перезаписи строк для ссылки на подконтексты. Один контекст может быть
псевдонимом другого. В этом случае контекст-псевдоним не содержит правил, и в результате любого
обращения к нему происходит доступ к тому контексту, псевдонимом которого он является.
.TP
.B rewriteRule "<regex match pattern>" "<substitution pattern>" "[ <flags> ]"
Определяет, как будет перезаписана строка, если было найдено совпадение с шаблоном.
Примеры приведены ниже.
.SH "Дополнительные директивы конфигурации"
.TP
.B rewriteMap "<map type>" "<map name>" "[ <map attrs> ]"
Позволяет определить карту, которая трансформирует перезапись подстроки во что-то иное. Ссылка на карту
происходит внутри шаблона подстановки правила.
.TP
.B rewriteParam <param name> <param value>
Задаёт значение с глобальной областью видимости, на которое можно сослаться командой `%{$paramName}'.
.TP
.B rewriteMaxPasses <number of passes> [<number of passes per rule>]
Задаётся максимальное общее количество проходов перезаписи, которое может быть выполнено в рамках одной
операции перезаписи (во избежание зацикливания). Безопасное значение по умолчанию - 100; имейте ввиду,
что достижение этого предела всё ещё интерпретируется как успешное выполнение операции; рекурсивный
вызов правил просто прерывается. Это ограничение применяется к операции перезаписи в целом, а не только
к одному правилу. Дополнительно может быть установлено ограничение на выполнение одного правила. Данное общее
ограничение переопределяется путём задания специфичных ограничений для конкретных правил с помощью флага `M{n}.
.SH "Примеры конфигурации"
.nf
# Для отключения перезаписи задайте значение `off'
rewriteEngine on

# Правила, реализуемые директивой "suffixmassage"
rewriteEngine on
# весь поток данных от клиента к серверу, в части, касающейся DN
rewriteContext default
rewriteRule "(.*)<virtualnamingcontext>$" "%1<realnamingcontext>" ":"
# пустое правило для фильтров
rewriteContext searchFilter
# весь поток данных от сервера к клиенту
rewriteContext searchResult
rewriteRule "(.*)<realnamingcontext>$" "%1<virtualnamingcontext>" ":"
rewriteContext searchAttrDN alias searchResult
rewriteContext matchedDN alias searchResult

# Всё, определённое здесь, относится к контексту `default'.
# Данное правило меняет контекст именования всего, что отправляется для
# `dc=home,dc=net' на `dc=ReOpenLDAP, dc=org'

rewriteRule "(.*)dc=home,[ ]?dc=net"
            "%1dc=ReOpenLDAP, dc=org"  ":"

# поскольку общепринятые/нормализованные DN не включают пробелов
# после разделителей rdn, например, `,', достаточно такого правила:

rewriteRule "(.*)dc=home,dc=net"
            "%1dc=ReOpenLDAP,dc=org"  ":"

# Начинается новый контекст (заканчивается ввод предыдущего).
# Это правило добавляет пробелы между частями DN, если их нет.
rewriteContext  addBlanks
rewriteRule     "(.*),([^ ].*)" "%1, %2"

# А это убирает пробелы
rewriteContext  eatBlanks
rewriteRule     "(.*),[ ](.*)" "%1,%2"

# Здесь управление переходит обратно к контексту перезаписи по
# умолчанию; правила добавляются в конец списка уже существующих.
# Всё, что попадает сюда, перенаправляется в правило `addBlanks'
rewriteContext  default
rewriteRule     ".*" "%{>addBlanks(%0)}" ":"

.\" # Anything with `uid=username' is looked up in
.\" # /etc/passwd for gecos (I know it's nearly useless,
.\" # but it is there just as a guideline to implementing
.\" # custom maps).
.\" # Note the `I' flag that leaves `uid=username' in place
.\" # if `username' does not have a valid account, and the
.\" # `:' that forces the rule to be processed exactly once.
.\" rewriteContext  uid2Gecos
.\" rewriteRule     "(.*)uid=([a-z0-9]+),(.+)"
.\"                 "%1cn=%2{xpasswd},%3"      "I:"
.\"
.\" # Finally, in a bind, if one uses a `uid=username' DN,
.\" # it is rewritten in `cn=name surname' if possible.
.\" rewriteContext  bindDN
.\" rewriteRule     ".*" "%{>addBlanks(%{>uid2Gecos(%0)})}" ":"
.\"
# Перезапись базы поискового запроса в соответствии с правилами
# `default'.
rewriteContext  searchBase alias default

# Результаты поиска с DN ReOpenLDAP перезаписываются обратно в
# контекст именования `dc=home,dc=net' с поглощением пробелов.
rewriteContext  searchResult
rewriteRule     "(.*[^ ]?)[ ]?dc=ReOpenLDAP,[ ]?dc=org"
                "%{>eatBlanks(%1)}dc=home,dc=net"    ":"

# Подсоединение с предоставлением адреса электронной почты
# вместо полного DN: для начала нам необходима ldap-карта,
# переводящая атрибуты в DN (аргумент, используемый при вызове
# карты добавляется к URI и выступает в качестве фильтра)
rewriteMap ldap attr2dn "ldap://host/dc=my,dc=org?dn?sub"

# Затем нам нужно выявить DN, представляющий собой только адрес
# электронной почты, например, `mail=someone@example.com';
# обратите внимание, что согласно этому правилу в случае нахождения
# совпадения перезапись останавливается; в случае возникновения
# ошибки, она будет проигнорирована. Если мы, кроме того,
# отображаем виртуальный контекст именования в реальный, нам также
# необходимо настроить перезапись обычных DN, поскольку правила
# контекста перезаписи bindDN переопределяют правила, настроенные
# по умолчанию.
rewriteContext bindDN
rewriteRule "^mail=[^,]+@[^,]+$" "%{attr2dn(%0)}" ":@I"

# Следующий пример довольно сложный. В нём поисковый фильтр преобразуется
# в случае, когда тот, кто выполняет поиск, имеет административные
# привилегии. Во-первых, мы должны отслеживать DN подсоединения
# входящих запросов и сохранять их в переменной `binddn', которая
# будет доступна в рамках всей сессии, а также оставлять их на месте
# для того, чтобы можно было осуществлять обычные подключения:
rewriteContext  bindDN
rewriteRule     ".+" "%{&&binddn(%0)}%0" ":"

# Поисковый фильтр, содержащий `uid=', перезаписывается, только
# если подсоединение осуществлялось от имени соответствующего DN.
# Чтобы сделать это, в первом правиле происходит подстановка DN
# подключения, а фильтр разбивается на префикс (переменная prefix),
# значение AVA `uid=<arg>' (переменная arg) и суффикс (переменная
# suffix). Тег `<>' добавляется в конец DN. Если DN указывает на
# запись в поддереве `ou=admin', фильтр перезаписывается: условие
# `uid=<arg>' соединяется с условием `cn=<arg>' через логическое ИЛИ;
# в противном случае всё остаётся как есть. Это может понадобиться,
# например, чтобы позволить модулю apache auth_ldap-1.4 аутентифицировать
# пользователей, логины которых могут быть либо в атрибуте `uid',
# либо в атрибуте `cn', но только если запрос поступает, например,
# от пользователя `cn=Web auth,ou=admin,dc=home,dc=net'.
rewriteContext searchFilter
rewriteRule "(.*\e\e()uid=([a-z0-9_]+)(\e\e).*)"
  "%{**binddn}<>%{&prefix(%1)}%{&arg(%2)}%{&suffix(%3)}"
  ":I"
rewriteRule "[^,]+,ou=admin,dc=home,dc=net"
  "%{*prefix}|(uid=%{*arg})(cn=%{*arg})%{*suffix}" ":@I"
rewriteRule ".*<>" "%{*prefix}uid=%{*arg}%{*suffix}" ":"

# В этом примере показано, как исключить нежелательные значения атрибутов,
# значениями которых являются DN, из результатов поиска. В первом правиле
# ищутся DN, оканчивающиеся на "ou=People,dc=example,dc=com"; в случае
# нахождения совпадения, перезапись успешно завершается. Второе правило
# совпадает со всем остальным, и приводит к тому, что значение будет отвергнуто.
rewriteContext searchResult
rewriteRule ".*,ou=People,dc=example,dc=com" "%0" ":@"
rewriteRule ".*" "" "#"
.fi
.SH "Определение LDAP-прокси (возможное развитие slapd\-ldap(5))"
В случае, когда в качестве DN перезаписи задаётся LDAP URI, операция инициируется в отношении хоста
host[:port], указанного в этом uri, если этот хост не представляет собой локальный сервер. Пример:
.LP
.nf
  rewriteRule '^cn=root,.*' '%0'                     'G{3}'
  rewriteRule '^cn=[a-l].*' 'ldap://ldap1.my.org/%0' ':@'
  rewriteRule '^cn=[m-z].*' 'ldap://ldap2.my.org/%0' ':@'
  rewriteRule '.*'          'ldap://ldap3.my.org/%0' ':@'
.fi
.LP
(Первое правило приведено здесь просто для иллюстрации действия `G{n}'; оно может быть перефразировано так:
.LP
.nf
  rewriteRule '^cn=root,.*' 'ldap://ldap3.my.org/%0' ':@'
.fi
.LP
тем самым экономится один проход перезаписи...).

.SH КОНТРОЛЬ ДОСТУПА
Механизм манипуляции данными
.B meta
не соблюдает все семантики ACL, описанные в man-странице
.BR slapd.access (5).
В общем случае, контроль доступа делегируется удалённому серверу (серверам).
Выполняется только проверка доступа на чтение
.B read (=r)
для псевдо-атрибута
.B entry
и других значений атрибутов записей, возвращаемых операцией
.BR search ,
поскольку она выполняется механизмом frontend.

.SH НАЛОЖЕНИЕ КЭШИРУЮЩЕГО ПРОКСИ-СЕРВЕРА
Наложение кэширующего прокси-сервера позволяет кэшировать поисковые запросы LDAP в локальной базе
данных. Подробнее смотрите в man-странице
.BR slapo\-pcache (5).

.SH УСТАРЕВШИЕ ДИРЕКТИВЫ
Приведённые в этом разделе директивы устарели, и их не следует больше использовать.

.TP
.B pseudorootdn "<DN-заместитель в случае подсоединения от имени rootdn>"
Вместо этой директивы используйте
.BR idassert\-bind .

.TP
.B pseudorootpw "<пароль-заместитель в случае подсоединения от имени rootdn>"
Вместо этой директивы используйте
.BR idassert\-bind .

.SH ФАЙЛЫ
.TP
@SYSCONFDIR@/slapd.conf
конфигурационный файл slapd по умолчанию.
.SH СМОТРИТЕ ТАКЖЕ
.BR slapd.conf (5),
.BR slapd\-ldap (5),
.BR slapo\-pcache (5),
.BR slapd (8),
.BR regex (7),
.BR re_format (7).
.SH АВТОР
Pierangelo Masarati, на основе модуля back-ldap, написанного Howard Chu.
